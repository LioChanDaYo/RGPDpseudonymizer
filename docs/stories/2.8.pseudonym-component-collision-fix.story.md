# Story 2.8: Pseudonym Component Collision Fix (CRITICAL BUG)

## Status

**Draft**

---

## Story

**As a** GDPR compliance officer,
**I want** pseudonym component assignments to be collision-free at the component level,
**so that** two different real entities never receive the same pseudonym, ensuring 1:1 reversible mapping (GDPR Article 4(5)).

---

## Context

**Bug Source:** Discovered during Story 2.7 (Batch Processing Scalability Spike) verification testing.

**Severity:** CRITICAL - BLOCKING for Epic 3

**GDPR Impact:** Violates Article 4(5) pseudonymization requirement (1:1 reversible mapping)

### Bug Description

During batch processing verification, two different real last names ("Dubois" and "Lefebvre") were assigned the same pseudonym ("Neto"), violating the fundamental 1:1 mapping requirement for GDPR-compliant pseudonymization.

**Sequence of Events:**
1. "Marie Dubois" processed → randomly assigned last name "Neto" → pseudonym "Alexia Neto"
2. "Pierre Lefebvre" processed → randomly assigned last name "Neto" → pseudonym "Maurice Neto"
3. By random chance, both full names received "Neto" as their last-name component
4. Standalone "Dubois" later found existing mapping → correctly reused "Neto"
5. Standalone "Lefebvre" later found existing mapping → correctly reused "Neto"
6. **Result:** Two different real entities now map to same pseudonym

**Root Cause:** `LibraryBasedPseudonymManager._used_pseudonyms` only tracks FULL pseudonyms (e.g., "Alexia Neto"), not individual components (e.g., "Neto"). Two people can have different full pseudonyms but share the same component.

**References:**
- Bug Report: [docs/architecture/CRITICAL-BUG-PSEUDONYM-COLLISION.md](../architecture/CRITICAL-BUG-PSEUDONYM-COLLISION.md)
- Spike Findings: [docs/architecture/batch-processing-spike-findings.md](../architecture/batch-processing-spike-findings.md) Issue 5
- Story 2.7: [docs/stories/2.7.batch-processing-scalability-spike.story.md](2.7.batch-processing-scalability-spike.story.md)

---

## Acceptance Criteria

1. **AC1:** Implement component-level collision prevention in LibraryBasedPseudonymManager
   - Add `_component_mappings` dictionary: `{(real_component, component_type) → pseudonym_component}`
   - Track all first-name and last-name component assignments
   - Prevent reuse of pseudonym component for different real component

2. **AC2:** Update `_select_first_name()` method
   - Accept optional `real_first_name: str | None` parameter
   - Check if `real_first_name` already has mapping in `_component_mappings`
   - If mapped, return existing pseudonym component
   - If not mapped, select new pseudonym component ensuring no collision
   - Store new mapping: `_component_mappings[(real_first_name, "first_name")] = selected_pseudonym`

3. **AC3:** Update `_select_last_name()` method
   - Accept optional `real_last_name: str | None` parameter
   - Check if `real_last_name` already has mapping in `_component_mappings`
   - If mapped, return existing pseudonym component
   - If not mapped, select new pseudonym component ensuring no collision
   - Store new mapping: `_component_mappings[(real_last_name, "last_name")] = selected_pseudonym`

4. **AC4:** Update `assign_pseudonym()` method signature
   - Pass `first_name` and `last_name` parameters to selection methods
   - Ensure compositional engine passes real component values (not just pseudonym hints)

5. **AC5:** Handle library exhaustion gracefully
   - If no collision-free component found after 100 attempts, raise RuntimeError
   - Log warning at 80% component exhaustion (same as full pseudonym logic)
   - Error message should indicate component exhaustion, not full pseudonym exhaustion

6. **AC6:** Add unit tests for component collision prevention
   - Test: Assign 100 different last names, verify all get unique pseudonyms
   - Test: Assign same real component multiple times, verify same pseudonym returned
   - Test: Assign different real components, verify no pseudonym collisions
   - Test: Library exhaustion handling (mock small library, verify RuntimeError)
   - Test: Component reuse via compositional logic (verify consistency)
   - Target coverage: 95% for modified methods

7. **AC7:** Add integration test for batch processing scenario
   - Process test documents with overlapping entities (e.g., "Marie Dubois", "Pierre Lefebvre", "Dubois", "Lefebvre")
   - Verify no duplicate pseudonyms in database after batch processing
   - Run Story 2.7 verification script: `scripts/verify_mapping_consistency.py`
   - All 5 consistency tests must PASS (currently 4/5 pass)

8. **AC8:** Update CompositionalPseudonymEngine integration
   - Ensure `parse_full_name()` results are passed to LibraryBasedPseudonymManager
   - Verify standalone component handling passes real component value
   - Test: "Dr. Dubois" should reuse "Dubois" component mapping from "Marie Dubois"

9. **AC9:** Backwards compatibility (database migration not required)
   - Existing database mappings remain valid
   - On first run, reconstruct `_component_mappings` from database via MappingRepository query
   - Query all entities, extract first/last names and pseudonym components
   - Populate `_component_mappings` to prevent future collisions with existing data

10. **AC10:** Performance validation
    - Component collision check should add <5ms overhead per assignment
    - Batch processing speedup should remain within 10% of Story 2.7 baseline
    - No memory leaks from `_component_mappings` growth (bounded by library size)

---

## Tasks / Subtasks

- [ ] **Task 1: Implement Component Collision Prevention** (AC: 1, 2, 3)
  - [ ] Add `_component_mappings` dict to LibraryBasedPseudonymManager.__init__()
  - [ ] Update `_select_first_name()` with collision prevention logic
  - [ ] Update `_select_last_name()` with collision prevention logic
  - [ ] Update `assign_pseudonym()` to pass real component values to selection methods
  - [ ] Add exhaustion handling for component-level selection (100 attempts)

- [ ] **Task 2: Update Compositional Engine Integration** (AC: 4, 8)
  - [ ] Verify CompositionalPseudonymEngine passes real component values
  - [ ] Update `assign_compositional_pseudonym()` to pass first_name/last_name
  - [ ] Test standalone component handling (e.g., "Dr. Dubois" should reuse "Dubois" mapping)

- [ ] **Task 3: Backwards Compatibility - Database Reconstruction** (AC: 9)
  - [ ] Add `_load_existing_mappings()` method to LibraryBasedPseudonymManager
  - [ ] Query MappingRepository for all entities on initialization
  - [ ] Extract first_name/last_name and pseudonym_first/pseudonym_last from database
  - [ ] Populate `_component_mappings` with existing data
  - [ ] Call `_load_existing_mappings()` in DocumentProcessor initialization

- [ ] **Task 4: Unit Tests for Component Collision Prevention** (AC: 6)
  - [ ] Test: 100 unique last names get 100 unique pseudonyms (no collisions)
  - [ ] Test: Same real component returns same pseudonym (idempotency)
  - [ ] Test: Different real components get different pseudonyms (collision prevention)
  - [ ] Test: Component exhaustion after N assignments (mock small library)
  - [ ] Test: Compositional reuse maintains consistency
  - [ ] Ensure 95% code coverage for modified methods

- [ ] **Task 5: Integration Tests for Batch Processing** (AC: 7)
  - [ ] Create test: Process documents with overlapping entities (Story 2.7 test corpus)
  - [ ] Verify no duplicate pseudonyms in database after processing
  - [ ] Run Story 2.7 verification script: `scripts/verify_mapping_consistency.py`
  - [ ] Verify all 5 consistency tests PASS (Test 4 currently fails)
  - [ ] Add test: Process 50+ documents with high entity overlap (stress test)

- [ ] **Task 6: Performance Validation** (AC: 10)
  - [ ] Measure component collision check overhead (<5ms target)
  - [ ] Run Story 2.7 batch processing spike, compare performance
  - [ ] Verify speedup within 10% of baseline (1.17x → 1.05x-1.29x acceptable)
  - [ ] Profile memory usage with 1000+ entities (verify no leaks)

- [ ] **Task 7: Documentation Updates**
  - [ ] Update [library_manager.py](gdpr_pseudonymizer/pseudonym/library_manager.py) docstrings
  - [ ] Document `_component_mappings` structure in class docstring
  - [ ] Add inline comments explaining collision prevention logic
  - [ ] Update Story 2.7 findings document: Mark Issue 5 as RESOLVED

---

## Dev Notes

### Affected Code Locations

**Primary Changes:**
- [gdpr_pseudonymizer/pseudonym/library_manager.py](gdpr_pseudonymizer/pseudonym/library_manager.py) lines 66-380
  - `LibraryBasedPseudonymManager.__init__()` (add `_component_mappings`)
  - `_select_first_name()` (add collision prevention)
  - `_select_last_name()` (add collision prevention)
  - `assign_pseudonym()` (pass real component values)

**Secondary Changes:**
- [gdpr_pseudonymizer/pseudonym/assignment_engine.py](gdpr_pseudonymizer/pseudonym/assignment_engine.py) lines 236-307
  - `CompositionalPseudonymEngine.assign_compositional_pseudonym()` (ensure real components passed)

**Integration Point:**
- [gdpr_pseudonymizer/core/document_processor.py](gdpr_pseudonymizer/core/document_processor.py) lines 60-100
  - Initialize LibraryBasedPseudonymManager with database mapping reconstruction

---

### Implementation Strategy

**Option 1: In-Memory Component Mapping (Recommended)**

Add component-level tracking to LibraryBasedPseudonymManager:

```python
class LibraryBasedPseudonymManager(PseudonymManager):
    def __init__(self) -> None:
        """Initialize pseudonym manager with collision prevention."""
        self.theme: str | None = None
        self.first_names: FirstNames = {"male": [], "female": [], "neutral": []}
        self.last_names: list[str] = []
        self._used_pseudonyms: set[str] = set()

        # NEW: Component-level collision prevention
        self._component_mappings: dict[tuple[str, str], str] = {}
        # Key: (real_component_value, component_type)
        # Value: pseudonym_component
        # Example: {("Dubois", "last_name"): "Neto", ("Marie", "first_name"): "Alexia"}

        self._fallback_counters: dict[str, int] = {
            "PERSON": 0,
            "LOCATION": 0,
            "ORG": 0,
        }

    def _select_last_name(self, real_last_name: str | None = None) -> str:
        """Select last name with component collision prevention.

        Args:
            real_last_name: Real last name component (for collision tracking)

        Returns:
            Pseudonym last name component

        Raises:
            RuntimeError: If no collision-free component found after 100 attempts
        """
        # Check if real_last_name already has mapping
        if real_last_name:
            mapping_key = (real_last_name, "last_name")
            if mapping_key in self._component_mappings:
                # Reuse existing mapping for consistency
                return self._component_mappings[mapping_key]

        # Select new pseudonym component, ensure no collision
        max_attempts = 100
        for attempt in range(max_attempts):
            candidate = secrets.choice(self.last_names)

            # Check if this pseudonym component already used for different real component
            # We need to check if ANY other real last name is already mapped to this pseudonym
            is_collision = False
            for (real_comp, comp_type), pseudo_comp in self._component_mappings.items():
                if comp_type == "last_name" and pseudo_comp == candidate:
                    # This pseudonym is already used for a different real last name
                    if real_last_name and real_comp != real_last_name:
                        is_collision = True
                        break

            if not is_collision:
                # No collision - safe to use this pseudonym component
                if real_last_name:
                    self._component_mappings[(real_last_name, "last_name")] = candidate
                return candidate

        # Failed to find collision-free component after max attempts
        raise RuntimeError(
            f"Unable to find unique last name component for '{real_last_name}' "
            f"after {max_attempts} attempts. Library may be exhausted."
        )

    def _select_first_name(self, gender: str | None, real_first_name: str | None = None) -> str:
        """Select first name with component collision prevention.

        Args:
            gender: Gender hint for name selection
            real_first_name: Real first name component (for collision tracking)

        Returns:
            Pseudonym first name component

        Raises:
            RuntimeError: If no collision-free component found after 100 attempts
        """
        # Check if real_first_name already has mapping
        if real_first_name:
            mapping_key = (real_first_name, "first_name")
            if mapping_key in self._component_mappings:
                return self._component_mappings[mapping_key]

        # Gender-based candidate selection
        if gender == "male" and self.first_names["male"]:
            candidates = self.first_names["male"]
        elif gender == "female" and self.first_names["female"]:
            candidates = self.first_names["female"]
        elif gender == "neutral" and self.first_names["neutral"]:
            candidates = self.first_names["neutral"]
        else:
            candidates = (
                self.first_names["male"]
                + self.first_names["female"]
                + self.first_names["neutral"]
            )

        if not candidates:
            raise RuntimeError(f"No first names available for gender: {gender}")

        # Select with collision prevention
        max_attempts = 100
        for attempt in range(max_attempts):
            candidate = secrets.choice(candidates)

            # Check for collision
            is_collision = False
            for (real_comp, comp_type), pseudo_comp in self._component_mappings.items():
                if comp_type == "first_name" and pseudo_comp == candidate:
                    if real_first_name and real_comp != real_first_name:
                        is_collision = True
                        break

            if not is_collision:
                if real_first_name:
                    self._component_mappings[(real_first_name, "first_name")] = candidate
                return candidate

        raise RuntimeError(
            f"Unable to find unique first name component for '{real_first_name}' "
            f"after {max_attempts} attempts. Library may be exhausted."
        )

    def assign_pseudonym(
        self,
        entity_type: str,
        first_name: str | None = None,
        last_name: str | None = None,
        gender: str | None = None,
        existing_first: str | None = None,
        existing_last: str | None = None,
    ) -> PseudonymAssignment:
        """Assign pseudonym with component-level collision prevention.

        Args:
            entity_type: Entity type (PERSON, LOCATION, ORG)
            first_name: Real first name component (for collision tracking)
            last_name: Real last name component (for collision tracking)
            gender: Gender hint for name selection
            existing_first: Existing first name pseudonym to reuse
            existing_last: Existing last name pseudonym to reuse

        Returns:
            PseudonymAssignment with collision-free components
        """
        # ... existing validation code ...

        # Compositional logic with component collision prevention
        pseudonym_first_name = existing_first
        pseudonym_last_name = existing_last

        # Generate pseudonym based on entity type
        if entity_type == "PERSON":
            if pseudonym_first_name is None:
                # Pass real first name for collision tracking
                pseudonym_first_name = self._select_first_name(gender, first_name)
            if pseudonym_last_name is None:
                # Pass real last name for collision tracking
                pseudonym_last_name = self._select_last_name(last_name)

            pseudonym_full = f"{pseudonym_first_name} {pseudonym_last_name}"
        else:
            # LOCATION and ORG use only last names
            pseudonym_first_name = None
            if pseudonym_last_name is None:
                pseudonym_last_name = self._select_last_name(None)
            pseudonym_full = pseudonym_last_name

        # Check for full pseudonym collision (existing logic)
        if pseudonym_full in self._used_pseudonyms:
            # ... existing fallback logic ...
            pass

        self._used_pseudonyms.add(pseudonym_full)

        return PseudonymAssignment(
            pseudonym_full=pseudonym_full,
            pseudonym_first=pseudonym_first_name,
            pseudonym_last=pseudonym_last_name,
            theme=self.theme,
            exhaustion_percentage=self.check_exhaustion(),
        )
```

**Database Reconstruction (Backwards Compatibility):**

```python
# In DocumentProcessor.__init__() or similar initialization
def _initialize_pseudonym_manager_with_existing_mappings(
    self, mapping_repo: MappingRepository
) -> LibraryBasedPseudonymManager:
    """Initialize pseudonym manager with existing database mappings.

    Reconstructs component mappings from database to prevent collisions
    with previously assigned pseudonyms.
    """
    pseudonym_manager = LibraryBasedPseudonymManager()
    pseudonym_manager.load_library(self.theme)

    # Query all existing entities from database
    existing_entities = mapping_repo.find_all()

    # Reconstruct component mappings
    for entity in existing_entities:
        if entity.entity_type == "PERSON":
            # Extract real components and pseudonym components
            if entity.first_name and entity.pseudonym_first:
                key = (entity.first_name, "first_name")
                pseudonym_manager._component_mappings[key] = entity.pseudonym_first

            if entity.last_name and entity.pseudonym_last:
                key = (entity.last_name, "last_name")
                pseudonym_manager._component_mappings[key] = entity.pseudonym_last

        # Track full pseudonym as used
        pseudonym_manager._used_pseudonyms.add(entity.pseudonym_full)

    logger.info(
        "Loaded %d existing component mappings from database",
        len(pseudonym_manager._component_mappings)
    )

    return pseudonym_manager
```

---

### Testing Strategy

**Unit Tests (tests/unit/test_library_manager_collision_fix.py):**

```python
def test_component_collision_prevention():
    """Verify different real components get different pseudonyms."""
    manager = LibraryBasedPseudonymManager()
    manager.load_library("neutral")

    # Assign pseudonyms for "Marie Dubois" and "Pierre Lefebvre"
    assignment1 = manager.assign_pseudonym(
        entity_type="PERSON",
        first_name="Marie",
        last_name="Dubois",
        gender="female"
    )

    assignment2 = manager.assign_pseudonym(
        entity_type="PERSON",
        first_name="Pierre",
        last_name="Lefebvre",
        gender="male"
    )

    # Verify last names got different pseudonyms
    assert assignment1.pseudonym_last != assignment2.pseudonym_last

    # Now process standalone "Dubois" and "Lefebvre"
    assignment3 = manager.assign_pseudonym(
        entity_type="PERSON",
        first_name="Dubois",  # Standalone component
        last_name=None,
        gender=None
    )

    assignment4 = manager.assign_pseudonym(
        entity_type="PERSON",
        first_name="Lefebvre",  # Standalone component
        last_name=None,
        gender=None
    )

    # Verify standalone components reuse correct mappings
    assert assignment3.pseudonym_full == assignment1.pseudonym_last
    assert assignment4.pseudonym_full == assignment2.pseudonym_last

    # CRITICAL: Verify no duplicate pseudonyms
    all_pseudonyms = {
        assignment1.pseudonym_full,
        assignment2.pseudonym_full,
        assignment3.pseudonym_full,
        assignment4.pseudonym_full,
    }
    assert len(all_pseudonyms) == 4  # All unique


def test_100_unique_last_names_no_collisions():
    """Verify 100 different last names get 100 unique pseudonyms."""
    manager = LibraryBasedPseudonymManager()
    manager.load_library("neutral")

    pseudonyms = set()
    for i in range(100):
        real_last_name = f"LastName{i:03d}"
        assignment = manager.assign_pseudonym(
            entity_type="PERSON",
            first_name="Test",
            last_name=real_last_name,
            gender="neutral"
        )
        pseudonyms.add(assignment.pseudonym_last)

    # All 100 should be unique
    assert len(pseudonyms) == 100
```

**Integration Test (tests/integration/test_batch_processing_collision_fix.py):**

```python
def test_story_27_verification_passes():
    """Verify Story 2.7 consistency tests now pass with fix."""
    # Use Story 2.7 test corpus
    db_path = "tests/fixtures/batch_spike/spike_test.db"
    passphrase = "spike_test_passphrase_2024"

    # Clean database
    if Path(db_path).exists():
        Path(db_path).unlink()

    # Process batch with overlapping entities
    # (reuse Story 2.7 batch_processing_spike.py logic)

    # Run verification
    with open_database(db_path, passphrase) as db_session:
        session = db_session.session

        # Test 4: Check for duplicate pseudonyms (MUST PASS NOW)
        duplicate_pseudonyms = session.execute(text("""
            SELECT pseudonym_full, COUNT(*) as count
            FROM entities
            WHERE entity_type = 'PERSON'
            GROUP BY pseudonym_full
            HAVING count > 1
        """)).fetchall()

        # CRITICAL: No duplicate pseudonyms allowed
        assert len(duplicate_pseudonyms) == 0, \
            f"Found {len(duplicate_pseudonyms)} duplicate pseudonyms: {duplicate_pseudonyms}"
```

---

### Performance Considerations

**Expected Overhead:**
- Component collision check: O(N) where N = number of existing component mappings
- For typical use: N < 100 per batch → <1ms overhead
- For large batches: N = 1000 → 3-5ms overhead (acceptable)

**Memory Usage:**
- `_component_mappings` dict: ~100 bytes per entry
- 1000 entries = ~100KB (negligible)
- Bounded by library size (max 1000 entries for 500-name library)

**Optimization (if needed):**
- Use reverse mapping: `{pseudonym_component → real_component}` for O(1) collision check
- Trade-off: Slightly more complex logic, same memory usage

---

### Backwards Compatibility

**Database Migration:** NOT REQUIRED
- Existing entities remain valid
- On first run, reconstruct `_component_mappings` from database
- Future assignments respect existing mappings

**Breaking Changes:** NONE
- Method signatures updated with optional parameters (default None)
- Existing code continues to work (just without collision prevention if not passing real components)

---

## Testing

**Source:** [docs/architecture/16-testing-strategy.md](../architecture/16-testing-strategy.md)

**Unit Tests:**
- Test file: `tests/unit/test_library_manager_collision_fix.py`
- Coverage target: 95% for modified methods
- Test cases: Component collision prevention, idempotency, exhaustion handling

**Integration Tests:**
- Test file: `tests/integration/test_batch_processing_collision_fix.py`
- Use Story 2.7 test corpus (overlapping entities)
- Run Story 2.7 verification script: `scripts/verify_mapping_consistency.py`
- All 5 consistency tests must PASS

**Performance Tests:**
- Measure overhead: <5ms per assignment
- Batch processing speedup: Within 10% of Story 2.7 baseline

**Test Execution:**
```bash
# Run unit tests
poetry run pytest tests/unit/test_library_manager_collision_fix.py -v

# Run integration tests
poetry run pytest tests/integration/test_batch_processing_collision_fix.py -v

# Run Story 2.7 verification (should pass all 5 tests)
poetry run python scripts/verify_mapping_consistency.py

# Full test suite
poetry run pytest tests/ -v --cov=gdpr_pseudonymizer
```

---

## Coding Standards

**Source:** [docs/architecture/19-coding-standards.md](../architecture/19-coding-standards.md)

**Type Hints:** Required for all public methods
```python
def _select_last_name(self, real_last_name: str | None = None) -> str:
```

**Logging:** No sensitive data (use component counts, not values)
```python
logger.info("Loaded %d existing component mappings from database", len(mappings))
logger.warning("Component collision detected, retrying (attempt %d/100)", attempt)
```

**Error Handling:** Clear error messages
```python
raise RuntimeError(
    f"Unable to find unique last name component for '{real_last_name}' "
    f"after 100 attempts. Library may be exhausted."
)
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-29 | 1.0 | Story created based on Story 2.7 critical bug discovery. Implements component-level collision prevention in LibraryBasedPseudonymManager. | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent during implementation_

### Implementation Summary

_To be filled by dev agent during implementation_

### Debug Log References

_To be filled by dev agent during implementation_

### Completion Notes

_To be filled by dev agent during implementation_

### File List

**Files to Modify:**
- gdpr_pseudonymizer/pseudonym/library_manager.py (component collision prevention)
- gdpr_pseudonymizer/pseudonym/assignment_engine.py (pass real components)
- gdpr_pseudonymizer/core/document_processor.py (database reconstruction)

**New Test Files:**
- tests/unit/test_library_manager_collision_fix.py
- tests/integration/test_batch_processing_collision_fix.py

**Documentation Updates:**
- docs/architecture/batch-processing-spike-findings.md (mark Issue 5 as RESOLVED)
- docs/architecture/CRITICAL-BUG-PSEUDONYM-COLLISION.md (update status)

### Change Log

_To be filled by dev agent during implementation_

---

## QA Results

_To be filled by QA agent during review_
