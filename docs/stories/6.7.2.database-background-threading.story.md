# Story 6.7.2: Database Background Threading (FE-021)

## Status

**Draft**

---

## Story

**As a** user managing a mapping database with hundreds or thousands of entities,
**I want** all database operations (listing, search, deletion, export) to run on a background thread,
**so that** the GUI remains responsive and I can continue interacting with the application during long operations.

---

## Acceptance Criteria

1. **AC1 — Entity Listing on Background Thread:**
   - `DatabaseScreen._load_entities()` runs the `repo.find_all()` query on a background thread via `QThreadPool + WorkerSignals`
   - A loading indicator (progress bar or spinner) is shown while the query executes
   - The entity table is populated on the GUI thread via the `finished` signal
   - Main GUI thread remains responsive during loading

2. **AC2 — Search/Filter on Background Thread:**
   - Search and type filter operations run on a background thread when entity count exceeds a threshold (e.g., 200+ entities)
   - For small datasets (<200 entities), in-memory filtering on the GUI thread remains acceptable
   - No UI freezing during search on large datasets

3. **AC3 — Article 17 Deletion on Background Thread:**
   - Entity deletion operations run on a background thread
   - A progress indicator is shown during multi-entity deletion
   - Audit logging (ERASURE operation) happens within the same background task
   - The entity table refreshes after deletion completes

4. **AC4 — CSV Export on Background Thread:**
   - CSV export runs on a background thread
   - A progress indicator is shown for large exports
   - Toast notification confirms completion

5. **AC5 — Error Handling:**
   - All background operations emit user-friendly error messages via the `error` signal
   - Passphrase errors clear the cached passphrase and prompt retry
   - Database corruption errors are reported clearly
   - No silent failures — every error path produces user feedback

6. **AC6 — Performance Verification:**
   - GUI does not freeze when opening a database with 1000+ entities
   - Search remains responsive with 1000+ entities
   - Deletion of 50+ entities does not freeze the GUI
   - CSV export of 1000+ entities does not freeze the GUI

7. **AC7 — Unit Tests:**
   - `DatabaseWorker` tested for all operation types (list, search, delete, export)
   - Error handling paths tested (DB corruption, passphrase error, write failure)
   - Signal emission verified (progress, finished, error)

8. **AC8 — No Regression:**
   - All existing tests pass (CLI + GUI)
   - Quality gates pass (Black, Ruff, mypy)
   - Coverage >= 86%
   - DatabaseScreen existing functionality preserved (UI, accessibility labels, i18n)

---

## Tasks / Subtasks

### Phase 1 — Database Worker Implementation (AC: 1-5)

- [ ] **Task 1: Create DatabaseWorker** (AC: 1-5)
  - [ ] 1.1: Create `gui/workers/database_worker.py` with `DatabaseWorker(QRunnable)` class
  - [ ] 1.2: Implement `DatabaseWorker.__init__(operation, db_path, passphrase, **kwargs)` — accepts operation type string and operation-specific kwargs
  - [ ] 1.3: Implement `run()` with lazy imports of `open_database`, `SQLiteMappingRepository`, `AuditRepository`
  - [ ] 1.4: Implement `_list_entities()` operation — opens DB, calls `repo.find_all()`, emits `finished` with entity list
  - [ ] 1.5: Implement `_search_entities(search_text, type_filter)` operation — opens DB, queries and filters, emits `finished` with filtered list
  - [ ] 1.6: Implement `_delete_entities(entity_ids)` operation — opens DB, deletes each entity, logs ERASURE audit op, emits `finished` with deleted count
  - [ ] 1.7: Implement `_export_csv(filepath, entities)` operation — writes CSV file, emits `finished` on success
  - [ ] 1.8: All operations emit `progress(percent, message)` at key stages
  - [ ] 1.9: All operations catch and handle `ValueError` (passphrase), `EncryptionError`, `DatabaseError`, `OSError` — emit user-friendly French error messages via `error` signal
  - [ ] 1.10: Update `gui/workers/__init__.py` to export `DatabaseWorker`

### Phase 2 — DatabaseScreen Migration (AC: 1-5)

- [ ] **Task 2: Add loading indicator to DatabaseScreen** (AC: 1)
  - [ ] 2.1: Add a `QProgressBar` (or `QLabel` spinner) to the DatabaseScreen layout, hidden by default
  - [ ] 2.2: Show loading indicator when background operation starts, hide on completion
  - [ ] 2.3: Disable interactive controls (search, delete, export buttons) during background operations to prevent concurrent access
  - [ ] 2.4: Add accessible labels to the loading indicator

- [ ] **Task 3: Migrate _load_entities to background thread** (AC: 1)
  - [ ] 3.1: Replace synchronous `_load_entities()` body with `DatabaseWorker("list", ...)` submission to `QThreadPool.globalInstance()`
  - [ ] 3.2: Connect `worker.signals.finished` to new `_on_entities_loaded(entities)` slot that populates the table
  - [ ] 3.3: Connect `worker.signals.error` to `_on_db_error(message)` slot that shows toast
  - [ ] 3.4: Show loading indicator during operation
  - [ ] 3.5: DB info line (creation date, entity count, last operation) must still be populated — include this data in the worker result

- [ ] **Task 4: Migrate search/filter to background thread** (AC: 2)
  - [ ] 4.1: Add threshold check in `_apply_filters()` — if `len(self._entities) > 200`, use background worker; otherwise keep in-memory filtering
  - [ ] 4.2: For background search: submit `DatabaseWorker("search", ..., search_text=..., type_filter=...)` to thread pool
  - [ ] 4.3: Debounce search input (300ms delay via `QTimer.singleShot`) to avoid spawning a worker per keystroke
  - [ ] 4.4: Connect finished signal to `_on_search_complete(filtered_entities)` slot

- [ ] **Task 5: Migrate deletion to background thread** (AC: 3)
  - [ ] 5.1: Replace synchronous deletion in `_delete_selected()` with `DatabaseWorker("delete", ..., entity_ids=...)` submission
  - [ ] 5.2: Connect finished signal to `_on_delete_complete(deleted_count)` — show toast, reload entities
  - [ ] 5.3: Show progress indicator during deletion
  - [ ] 5.4: Disable delete button during operation

- [ ] **Task 6: Migrate CSV export to background thread** (AC: 4)
  - [ ] 6.1: Replace synchronous CSV write in `_export_csv()` with `DatabaseWorker("export", ..., filepath=..., entities=...)`
  - [ ] 6.2: Connect finished signal to `_on_export_complete()` — show toast
  - [ ] 6.3: Show progress indicator during export

### Phase 3 — Testing (AC: 6, 7, 8)

- [ ] **Task 7: Write DatabaseWorker unit tests** (AC: 7)
  - [ ] 7.1: Create `tests/unit/gui/test_database_worker.py`
  - [ ] 7.2: Test list_entities operation — mock DB session, verify finished signal emits entity list
  - [ ] 7.3: Test search_entities operation — verify filtering logic
  - [ ] 7.4: Test delete_entities operation — verify deletion + audit logging
  - [ ] 7.5: Test export_csv operation — verify file written correctly
  - [ ] 7.6: Test error handling — passphrase error, DB corruption, write failure
  - [ ] 7.7: Test signal emission order (progress → finished or progress → error)

- [ ] **Task 8: Performance verification** (AC: 6)
  - [ ] 8.1: Create a test database with 1000+ entities (script or fixture)
  - [ ] 8.2: Manual test: open database with 1000+ entities — verify no UI freeze
  - [ ] 8.3: Manual test: search with 1000+ entities — verify responsiveness
  - [ ] 8.4: Manual test: delete 50+ entities — verify no UI freeze
  - [ ] 8.5: Manual test: export 1000+ entities to CSV — verify no UI freeze
  - [ ] 8.6: Document results in story completion notes

- [ ] **Task 9: Regression verification** (AC: 8)
  - [ ] 9.1: Run `poetry run pytest tests/unit/cli/ tests/integration/` — all pass
  - [ ] 9.2: Run `poetry run pytest tests/unit/gui/` — all pass
  - [ ] 9.3: Run quality gates (Black, Ruff, mypy) — all pass
  - [ ] 9.4: Verify coverage >= 86%

---

## Dev Notes

### Existing Worker Pattern

The project has an established `QRunnable + WorkerSignals` pattern used in all GUI workers. Follow the same pattern:

**Worker signals** (`gui/workers/signals.py`):
```python
class WorkerSignals(QObject):
    progress = Signal(int, str)   # (percent, phase_label)
    finished = Signal(object)     # success result
    error = Signal(str)           # user-friendly error message
```

**Existing workers to follow as examples:**
- `gui/workers/processing_worker.py` — `ProcessingWorker` for document processing
- `gui/workers/detection_worker.py` — `DetectionWorker` for NLP detection phase
- `gui/workers/finalization_worker.py` — `FinalizationWorker` for pseudonymization finalization
- `gui/workers/batch_worker.py` — `BatchWorker` for batch processing

**Key pattern rules:**
- Worker class extends `QRunnable`, creates `WorkerSignals` instance in `__init__`
- `self.setAutoDelete(True)` — Qt garbage-collects after run
- Use lazy imports inside `run()` for heavy dependencies
- Emit French user-facing messages for errors
- Never access Qt widgets from the worker thread — only emit signals

### Current DatabaseScreen Operations (All on GUI Thread)

| Operation | Location | Current Implementation |
|-----------|----------|----------------------|
| Load entities | `_load_entities()` | Synchronous `repo.find_all()` in `with open_database(...)` |
| Search/filter | `_apply_filters()` | In-memory filter on `self._entities` list |
| Delete | `_delete_selected()` | Synchronous loop over `repo.delete_entity_by_id()` |
| CSV export | `_export_csv()` | Synchronous `csv.writer` loop |

**Note on search:** The current search is in-memory against the already-loaded `self._entities` list, which is fast for small datasets. Only the initial `_load_entities()` is slow. The search worker is primarily needed if we want to avoid keeping all entities in memory for very large databases. For v2.0, keeping the in-memory filter for small datasets and threading only for large ones is acceptable.

### Concurrency Safety

- The `DatabaseScreen` must prevent concurrent background operations — disable interactive controls while a worker is running
- Use a `_current_worker: DatabaseWorker | None` field to track the active worker
- Cancel any in-flight worker before starting a new one (e.g., user triggers search while load is still running)

### Thread-Safe Database Access

- Each worker opens its own `open_database()` session (context manager pattern)
- No shared database session across threads
- The `open_database` context manager handles encryption/decryption lifecycle

### Accessibility

All new UI elements (loading indicator, progress bar) must have:
- `setAccessibleName()` in French
- `setAccessibleDescription()` in French
- Proper focus order integration (update `setup_focus_order_database()` if needed)

### Previous Story Insights

- **CODE-003 Pattern:** Never use UI text for state logic — use boolean flags or enums. [Source: Story 6.6]
- **Quality Gates:** Black, Ruff, mypy, pytest must all pass. [Source: Story 6.7]
- **Poetry:** All commands must use `poetry run`. [Source: architecture/19-coding-standards.md]
- **i18n:** All user-facing strings must go through `self.tr()` or `qarg()`. [Source: Story 6.6]

### Source File Locations

| File | Role |
|------|------|
| `gdpr_pseudonymizer/gui/screens/database.py` | Primary modification target — migrate operations to background |
| `gdpr_pseudonymizer/gui/workers/signals.py` | Existing `WorkerSignals` — reuse as-is |
| `gdpr_pseudonymizer/gui/workers/processing_worker.py` | Reference implementation for worker pattern |
| `gdpr_pseudonymizer/gui/workers/__init__.py` | Update exports |
| `gdpr_pseudonymizer/gui/accessibility/focus_manager.py` | May need update for new UI elements |
| `gdpr_pseudonymizer/data/database.py` | `open_database()` context manager |
| `gdpr_pseudonymizer/data/repositories/mapping_repository.py` | `SQLiteMappingRepository` — `find_all()`, `delete_entity_by_id()` |
| `gdpr_pseudonymizer/data/repositories/audit_repository.py` | `AuditRepository` — `log_operation()`, `find_operations()` |

### Testing

**Test File Locations:**
- `tests/unit/gui/test_database_worker.py` — new file for worker unit tests
- `tests/unit/gui/test_database_screen.py` — if exists, update; otherwise test via worker

**Testing Framework and Patterns:**
- pytest + pytest-qt
- Mock `open_database` and repositories for unit tests
- Use `QSignalSpy` or manual signal capture for verifying signal emission
- Follow existing worker test patterns in `tests/unit/gui/`

**Performance Testing:**
- Manual testing required with large database (1000+ entities)
- Create a seed script or fixture that populates a test database
- Document results in completion notes

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-25 | 1.0 | Initial story draft — extracted from Story 6.7 AC7 (FE-021, deferred from Story 6.5 PERF-001) | Sarah (Product Owner) |
